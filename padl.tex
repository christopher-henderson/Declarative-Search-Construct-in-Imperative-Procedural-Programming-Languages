% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{syntax}
\usepackage{listings}
\usepackage{listings-rust}
\usepackage{listings-golang}

% Better inline directory listings
% \usepackage{xcolor}
% \definecolor{light-gray}{gray}{0.95}
% \newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{Declarative Search Construct in Imperative/Procedural Programming Languages}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Christopher Henderson\inst{1} \and Ajay Bansal\inst{1}}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Arizona State University, Tempe AZ 85281, USA
\url{https://www.asu.edu}
}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Graph theory is a critical component of computer science and software engineering, with algorithms concerning graph traversal and comprehension powering much of the complex problems in both industry and research. Engineers and researchers often have an accurate view of their target graph, however they struggle to implement a correct, and efficient, search over that graph. Even though modern imperative languages provide libraries for graph search, there are no built-in constructs for search with separation of concerns, that is separate the implementation of graph traversal from the userâ€™s desired search result. In this paper, we propose a new programming language construct, the search statement, in order to facilitate rapid, correct, efficient, and intuitive development of graph-based solutions. Given a supra-root node, a procedure which determines the children of a given parent node, and optional definitions of the fail-fast acceptance or rejection of a solution, the search statement can conduct a search over any graph or network. Structurally, this statement is modeled after the common switch statement and is put into a largely imperative/procedural context to allow for declarative and intuitive development by most programmers. The Go programming language has been used as a foundation and proof-of-concept of the search statement. 

\keywords 
{
Backtracking \and
Graph Search \and
Imperative Programming \and
Declarative Programming
}

\end{abstract}


\section{Introduction}

\section{Methodology}

\section{The \code{search} statement}

\subsection{\code{search} signature}

\subsection{\code{children}}
Given a procedure that accepts a node and returns a list of nodes, a graph may be traversed in an arbitrary fashion.
\\
Optionally, the \code{children} procedure may be provided with a list of nodes representing the solution computed thus far. This is to facilitate algorithms who make their decisions via heuristics.

\subsection{\code{reject}}

\subsection{\code{accept}}
Given a list of nodes that represents the computed solution thus far the \code{accept} procedure returns a boolean value indicating whether or not the solution in question is a whole, complete, and correct solution to the current problem.

\section{Psuedo Code Implementation}

\section{EBNF Grammar}
This section provides the extended Backus-Naur form (EBNF) of the \code{search} construct. These grammars are only meaningful within the context of an extant grammar, the definition of which is outside the scope of this paper. As such, common definitions such as \code{statement-list} and \code{expr} have been elided and are to be taken as their common meanings.

\subsection{Idealic Grammar}
The following is the extended Backus-Naur form of the idealic candidate search construct.
\begin{grammar}
<search> ::= `search' <expr> [; <natural-number-expr>] `{' <search-block> `}'

<search-block> ::= `children' `:' <statement-list> [`accept' `:' <statement-list>][`reject' `:' <statement-list>]
\end{grammar}

\subsection{Implemented Grammar}
The following is the extended Backus-Naur form of the \code{search} construct as implemented in the Go programming language. It's defining difference is the admittance of a need to inform the compiler of the type of the initializing \code{expr} in the \code{search} signature.

\begin{grammar}
<search> ::= `search' <expr>; <type-specifier> [; <natural-number-expr>] `{' <search-block> `}'

<search-block> ::= `children' `:' <statement-list> [`accept' `:' <statement-list>][`reject' `:' <statement-list>]
\end{grammar}

The \code{search} construct is itself a statement and, as such, may be recursively nested within itself.

\section{Implementations}

\subsection{The Go Programming Language}

\subsubsection{Code Samples}

\subsection{The Rust Programming Language}


\subsubsection{Code Samples}

\appendix

\section{Rust Implementation}
\begin{lstlisting}[language=Rust, style=boxed]
pub fn search<T>(
	fcg: T,
	reject: &mut FnMut(&[T], 
	&T) -> bool, accept: &mut FnMut(&[T]) -> bool)
where
    T: Iterator<Item = T>,
{
    let mut root_pointer: usize = 0;
    let mut core = vec![fcg];
    loop {
        if let Some(candidate) = unsafe {
        	core.get_unchecked_mut(root_pointer) }.next() {
            if reject(&core[1..], &candidate) {
                continue;
            }
            core.push(candidate);
            if accept(&core[1..]) {
                core.pop();
                continue;
            }
            root_pointer += 1;
        } else {
            core.pop();
            if root_pointer == 0 {
                break;
            }
            root_pointer -= 1;
        }
    }
}
\end{lstlisting}

\section{Go Implementation}
\begin{lstlisting}[language=Golang, style=boxed]
// This is the one piece of internals that the userland
	// can potentially see.
	type __GraphNode struct {
		Active	 bool
		ID       int
		Parent   int
	}
	// User CHILDREN declaration.
	USER_children := func(node {UTYPE}, solution []{UTYPE}, gid *__GraphNode) <-chan {UTYPE} {
		return make(chan {UTYPE}, 0)
	}
	// User ACCEPT declaration.
	USER_accept := func(node {UTYPE}, solution []{UTYPE}, gid *__GraphNode) bool {
		return false
	}
	// User REJECT declaration.
	USER_reject := func(node {UTYPE}, solution []{UTYPE}, gid *__GraphNode) bool {
		return false
	}
	root := changeme
	maxgoroutine := 1
	// Parent:Children PODO meant for stack management.
	type StackEntry struct {
		Parent   {UTYPE}
		Children <-chan {UTYPE}
	}
	lock := make(chan int, maxgoroutine)
	wg := make(chan int, maxgoroutine)
	ticket := make(chan int, maxgoroutine)
	// You have to declare first since the function can fire off a
	// goroutine of itself.
	var engine func(solution []{UTYPE}, root {UTYPE}, gid *__GraphNode)
	engine = func(solution []{UTYPE}, root {UTYPE}, gid *__GraphNode) {
		_children := USER_children(root, solution, gid)
		// Stack of Parent:Chidren pairs.
		stack := make([]StackEntry, 0)
		// Current candidate under consideration.
		var candidate {UTYPE}
		// Holds a StackEntry.
		var stackEntry StackEntry
		// Generic boolean variable
		var ok bool
		for {
			if candidate, ok = <-_children; !ok {
				// This node has no further children.
				if len(stack) == 0 {
					// Algorithm termination. No further nodes in the stack.
					break
				}
				// With no valid children left, we pop the latest node from the solution.
				solution = solution[:len(solution)-1]
				// Pop from the stack. Broken into two steps:
				// 	1. Get final element.
				//	2. Resize the stack.
				stackEntry = stack[len(stack)-1]
				stack = stack[:len(stack)-1]
				// Extract root and candidate fields from the StackEntry.
				root = stackEntry.Parent
				_children = stackEntry.Children
				continue
			}
			// Ask the user if we should reject this candidate.
			_reject := USER_reject(candidate, solution, gid)
			if _reject {
				// Rejected candidate.
				continue
			}
			// Append the candidate to the solution.
			solution = append(solution, candidate)
			// Ask the user if we should accept this solution.
			_accept := USER_accept(candidate, solution, gid)
			if _accept {
				// Accepted solution.
				// Pop from the solution thus far and continue on with the next child.
				solution = solution[:len(solution)-1]
				continue
			}
			select {
				case lock <- 1:
					wg <- 1
					s := make([]{UTYPE}, len(solution))
					copy(s, solution)
					go engine(s, candidate, &__GraphNode{Active: true, ID: <-ticket, Parent: gid.ID})
					// pretend we didn't see this
					solution = solution[:len(solution)-1]
					continue
				default:
			}
			// Push the current root to the stack.
			stack = append(stack, StackEntry{root, _children})
			// Make the candidate the new root.
			root = candidate
			// Get the new root's children channel.
			_children = USER_children(root, solution, gid)
		}
		<- lock
		wg <- -1
		gid.Active = false
	}
	shutdown := make(chan struct{}, 0)
	go func() {
		// Goroutine ticketing system.
		id := 0
		for {
			select {
			case ticket <- id:
				id++
			case <-shutdown:
				close(ticket)
				return
			}
		}
	}()
	lock <- 1
	wg <- 1
	go engine(make([]{UTYPE}, 0), root, &__GraphNode{Active: true, ID: <-ticket, Parent: 0})
	count := 0
	for c := range wg {
		count += c
		if count == 0 {
			break
		}
	}
	close(shutdown)
	close(wg)
	close(lock)
\end{lstlisting}


\end{document}
